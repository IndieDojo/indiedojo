{"version":3,"sources":["../../../src/internal-plugins/query-runner/file-parser.js"],"names":["filePath","fileStr","ast","transpiled","length","item","tmp","babylon","parse","sourceType","plugins","console","info","undefined","error","sourceFilename","e","log","parseToAst","file","text","then","queries","ExportNamedDeclaration","path","state","traverse","TaggedTemplateExpression","innerPath","gqlAst","getGraphQLTag","definitions","forEach","def","name","value","stripIndent","process","exit","push","resolve","findGraphQLTags","fs","require","crypto","Bluebird","apiRunnerNode","cache","FileParser","readFileSync","indexOf","hash","createHash","update","digest","astDefinitions","kind","message","files","documents","all","map","parseFile","doc","set","catch"],"mappings":"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","file":"file-parser.js","sourcesContent":["// @flow\nconst fs = require(`fs-extra`)\nconst crypto = require(`crypto`)\n\n// Traverse is a es6 module...\nimport traverse from \"babel-traverse\"\nconst babylon = require(`babylon`)\nconst Bluebird = require(`bluebird`)\nconst { stripIndent } = require(`common-tags`)\n\nconst apiRunnerNode = require(`../../utils/api-runner-node`)\nconst { getGraphQLTag } = require(`../../utils/babel-plugin-extract-graphql`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\n\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  let transpiled\n  // TODO figure out why awaiting apiRunnerNode doesn't work\n  // Currently if I try that it just returns immediately.\n  //\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  // const transpiled = await apiRunnerNode(`preprocessSource`, {\n  // filename: filePath,\n  // contents: fileStr,\n  // })\n\n  if (transpiled && transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babylon.parse(item, {\n          sourceType: `module`,\n          plugins: [`*`],\n        })\n        ast = tmp\n        break\n      } catch (e) {\n        console.info(e)\n        continue\n      }\n    }\n    if (ast === undefined) {\n      console.error(`Failed to parse preprocessed file ${filePath}`)\n    }\n  } else {\n    try {\n      ast = babylon.parse(fileStr, {\n        sourceType: `module`,\n        sourceFilename: true,\n        plugins: [`*`],\n      })\n    } catch (e) {\n      console.log(`Failed to parse ${filePath}`)\n      console.log(e)\n    }\n  }\n\n  return ast\n}\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  return new Promise(resolve => {\n    parseToAst(file, text).then(ast => {\n      if (!ast) return []\n\n      let queries = []\n      traverse(ast, {\n        ExportNamedDeclaration(path, state) {\n          path.traverse({\n            TaggedTemplateExpression(innerPath) {\n              const gqlAst = getGraphQLTag(innerPath)\n              if (gqlAst) {\n                gqlAst.definitions.forEach(def => {\n                  if (!def.name || !def.name.value) {\n                    console.log(stripIndent`\n                  GraphQL definitions must be \"named\".\n                  The query with the missing name is in ${file}.\n                  To fix the query, add \"query MyQueryName\" to the start of your query.\n                  So instead of:\n                  {\n                    allMarkdownRemark {\n                      totalCount\n                    }\n                  }\n\n                  Do:\n\n                  query MyQueryName {\n                    allMarkdownRemark {\n                      totalCount\n                    }\n                  }\n                `)\n                    process.exit(1)\n                  }\n                })\n\n                queries.push(...gqlAst.definitions)\n              }\n            },\n          })\n        },\n      })\n      resolve(queries)\n    })\n  })\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    // TODO figure out why fs-extra isn't returning a promise\n    const text = fs.readFileSync(file, `utf8`)\n\n    if (text.indexOf(`graphql`) === -1) return null\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    try {\n      let astDefinitions =\n        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n      return astDefinitions.length\n        ? {\n            kind: `Document`,\n            definitions: astDefinitions,\n          }\n        : null\n    } catch (err) {\n      console.error(`Failed to parse GQL query from file: ${file}`)\n      console.error(err.message)\n      return null\n    }\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n    return Promise.all(\n      files.map(\n        file =>\n          new Promise(resolve => {\n            this.parseFile(file)\n              .then(doc => {\n                if (doc) documents.set(file, doc)\n                resolve()\n              })\n              .catch(e => {\n                console.log(`parsing file failed`, file, e)\n              })\n          })\n      )\n    )\n      .then(() => documents)\n      .catch(e => {\n        console.log(`parsing files failed`, e)\n      })\n  }\n}\n"]}