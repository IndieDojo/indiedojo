{"version":3,"sources":["../../../src/internal-plugins/query-runner/page-query-runner.js"],"names":["_","require","Promise","store","emitter","queryRunner","queuedDirtyActions","active","exports","runQueries","state","getState","uniq","a","payload","id","findAndRunQueriesForDirtyPaths","paths","findPathsWithoutDataDependencies","all","map","page","pages","find","p","path","component","pageComponents","on","push","action","runQueuedActions","allTrackedPaths","flatten","concat","values","pageDataDependencies","nodes","connections","difference","dirtyPaths","actions","forEach","node","internal","type","length","resolve"],"mappings":"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","file":"page-query-runner.js","sourcesContent":["/**\n * Jobs of this module\n * - Ensure on bootstrap that all invalid page queries are run and report\n *   when this is done\n * - Watch for when a page's query is invalidated and re-run it.\n */\n\nconst _ = require(`lodash`)\nconst Promise = require(`bluebird`)\n\nconst { store, emitter } = require(`../../redux`)\nconst queryRunner = require(`./query-runner`)\n\nlet queuedDirtyActions = []\n\nlet active = false\n\nexports.runQueries = async () => {\n  active = true\n  const state = store.getState()\n\n  // Run queued dirty nodes now that we're active.\n  queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  await findAndRunQueriesForDirtyPaths(queuedDirtyActions)\n\n  // Find paths without data dependencies and run them (just in case?)\n  const paths = findPathsWithoutDataDependencies()\n  // Run these pages\n  await Promise.all(\n    paths.map(path => {\n      const page = state.pages.find(p => p.path === path)\n      const component = state.pageComponents[page.component]\n      return queryRunner(page, component)\n    })\n  )\n  return\n}\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nconst runQueuedActions = () => {\n  if (active) {\n    queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n    findAndRunQueriesForDirtyPaths(queuedDirtyActions)\n    queuedDirtyActions = []\n  }\n}\n\n// Wait until all plugins have finished running (e.g. various\n// transformer plugins) before running queries so we don't\n// query things in a 1/2 finished state.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedActions)\n\nconst findPathsWithoutDataDependencies = () => {\n  const state = store.getState()\n  const allTrackedPaths = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.pageDataDependencies.nodes),\n        _.values(state.pageDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  return _.difference(state.pages.map(p => p.path), allTrackedPaths)\n}\n\nconst findAndRunQueriesForDirtyPaths = actions => {\n  const state = store.getState()\n  let dirtyPaths = []\n  actions.forEach(action => {\n    const node = state.nodes[action.payload.id]\n\n    // Check if the node was deleted\n    if (!node) {\n      return\n    }\n\n    // Find invalid pages.\n    if (state.pageDataDependencies.nodes[node.id]) {\n      dirtyPaths = dirtyPaths.concat(state.pageDataDependencies.nodes[node.id])\n    }\n\n    // Find invalid connections\n    if (state.pageDataDependencies.connections[node.internal.type]) {\n      dirtyPaths = dirtyPaths.concat(\n        state.pageDataDependencies.connections[node.internal.type]\n      )\n    }\n  })\n\n  if (dirtyPaths.length > 0) {\n    // Run these pages\n    return Promise.all(\n      _.uniq(dirtyPaths).map(path => {\n        const page = state.pages.find(p => p.path === path)\n        if (page) {\n          const component = state.pageComponents[page.component]\n          return queryRunner(page, component)\n        }\n      })\n    )\n  } else {\n    return Promise.resolve()\n  }\n}\n"]}