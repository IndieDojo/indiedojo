{"version":3,"sources":["../../src/utils/api-runner-node.js"],"names":["Promise","require","glob","_","mapSeries","cache","apiList","boundPluginActionCreators","doubleBind","boundActionCreators","api","plugin","traceId","name","keys","doubleBoundActionCreators","i","key","boundActionCreator","args","length","runAPI","pathPrefix","store","loadNodeContent","getNodes","getNode","hasNodeChanged","getNodeAndSavePathDependency","getState","program","prefixPaths","config","gatsbyNode","resolve","apiCallArgs","pluginOptions","fromCallback","callback","result","filteredPlugins","hasAPIFile","sync","apisRunning","waitingForCasacadeToFinish","module","exports","pluginSource","console","log","process","exit","plugins","flattenedPlugins","filter","noSourcePluginPlugins","p","apiRunInstance","startTime","Date","toJSON","waitForCascadingActions","push","currentPluginName","asCallback","err","results","runner","emitter","emit","isEmpty","some","a","instance"],"mappings":"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","file":"api-runner-node.js","sourcesContent":["const Promise = require(`bluebird`)\nconst glob = require(`glob`)\nconst _ = require(`lodash`)\nconst mapSeries = require(`async/mapSeries`)\n\nconst cache = require(`./cache`)\n\nconst apiList = require(`./api-node-docs`)\n\n// Bind action creators per plugin so we can auto-add\n// metadata to actions they create.\nconst boundPluginActionCreators = {}\nconst doubleBind = (boundActionCreators, api, plugin, { traceId }) => {\n  if (boundPluginActionCreators[plugin.name + api + traceId]) {\n    return boundPluginActionCreators[plugin.name + api + traceId]\n  } else {\n    const keys = Object.keys(boundActionCreators)\n    const doubleBoundActionCreators = {}\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const boundActionCreator = boundActionCreators[key]\n      if (typeof boundActionCreator === `function`) {\n        doubleBoundActionCreators[key] = (...args) =>\n          boundActionCreator(...args, plugin, traceId)\n      }\n    }\n    boundPluginActionCreators[\n      plugin.name + api + traceId\n    ] = doubleBoundActionCreators\n    return doubleBoundActionCreators\n  }\n}\n\nconst runAPI = (plugin, api, args) => {\n  let pathPrefix = ``\n  const {\n    store,\n    loadNodeContent,\n    getNodes,\n    getNode,\n    hasNodeChanged,\n    getNodeAndSavePathDependency,\n  } = require(`../redux`)\n  const { boundActionCreators } = require(`../redux/actions`)\n\n  const doubleBoundActionCreators = doubleBind(\n    boundActionCreators,\n    api,\n    plugin,\n    args\n  )\n\n  if (store.getState().program.prefixPaths) {\n    pathPrefix = store.getState().config.pathPrefix\n  }\n\n  const gatsbyNode = require(`${plugin.resolve}/gatsby-node`)\n  if (gatsbyNode[api]) {\n    const apiCallArgs = [\n      {\n        ...args,\n        pathPrefix,\n        boundActionCreators: doubleBoundActionCreators,\n        loadNodeContent,\n        store,\n        getNodes,\n        getNode,\n        hasNodeChanged,\n        getNodeAndSavePathDependency,\n        cache,\n      },\n      plugin.pluginOptions,\n    ]\n\n    // If the plugin is using a callback use that otherwise\n    // expect a Promise to be returned.\n    if (gatsbyNode[api].length === 3) {\n      return Promise.fromCallback(callback =>\n        gatsbyNode[api](...apiCallArgs, callback)\n      )\n    } else {\n      const result = gatsbyNode[api](...apiCallArgs)\n      return Promise.resolve(result)\n    }\n  }\n\n  return null\n}\n\nlet filteredPlugins\nconst hasAPIFile = plugin => glob.sync(`${plugin.resolve}/gatsby-node*`)[0]\n\nlet apisRunning = []\nlet waitingForCasacadeToFinish = []\n\nmodule.exports = async (api, args = {}, pluginSource) =>\n  new Promise(resolve => {\n    // Check that the API is documented.\n    if (!apiList[api]) {\n      console.log(`api`, api, `is not yet documented`)\n      process.exit()\n    }\n\n    const { store } = require(`../redux`)\n    const plugins = store.getState().flattenedPlugins\n    // Get the list of plugins that implement gatsby-node\n    if (!filteredPlugins) {\n      filteredPlugins = plugins.filter(plugin => hasAPIFile(plugin))\n    }\n\n    // Break infinite loops.\n    // Sometimes a plugin will implement an API and call an\n    // action which will trigger the same API being called.\n    // \"onCreatePage\" is the only example right now.\n    // In these cases, we should avoid calling the originating plugin\n    // again.\n    let noSourcePluginPlugins = filteredPlugins\n    if (pluginSource) {\n      noSourcePluginPlugins = filteredPlugins.filter(\n        p => p.name !== pluginSource\n      )\n    }\n\n    const apiRunInstance = {\n      api,\n      args,\n      pluginSource,\n      resolve,\n      startTime: new Date().toJSON(),\n      traceId: args.traceId,\n    }\n\n    if (args.waitForCascadingActions) {\n      waitingForCasacadeToFinish.push(apiRunInstance)\n    }\n\n    apisRunning.push(apiRunInstance)\n\n    let currentPluginName = null\n\n    mapSeries(\n      noSourcePluginPlugins,\n      (plugin, callback) => {\n        currentPluginName = plugin.name\n        Promise.resolve(runAPI(plugin, api, args)).asCallback(callback)\n      },\n      (err, results) => {\n        if (err) {\n          console.log(``)\n          console.log(`Plugin ${currentPluginName} returned an error:`)\n          console.log(``)\n          console.log(err)\n        }\n        // Remove runner instance\n        apisRunning = apisRunning.filter(runner => runner !== apiRunInstance)\n\n        if (apisRunning.length === 0) {\n          const { emitter } = require(`../redux`)\n          emitter.emit(`API_RUNNING_QUEUE_EMPTY`)\n        }\n\n        // Filter empty results\n        apiRunInstance.results = results.filter(result => !_.isEmpty(result))\n\n        // Filter out empty responses and return if the\n        // api caller isn't waiting for cascading actions to finish.\n        if (!args.waitForCascadingActions) {\n          resolve(apiRunInstance.results)\n        }\n\n        // Check if any of our waiters are done.\n        waitingForCasacadeToFinish = waitingForCasacadeToFinish.filter(\n          instance => {\n            // If none of its trace IDs are running, it's done.\n            if (!_.some(apisRunning, a => a.traceId === instance.traceId)) {\n              instance.resolve(instance.results)\n              return false\n            } else {\n              return true\n            }\n          }\n        )\n      }\n    )\n  })\n"]}