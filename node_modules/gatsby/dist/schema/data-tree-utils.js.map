{"version":3,"sources":["../../src/schema/data-tree-utils.js"],"names":["_","require","flatten","typeOf","createKey","INVALID_VALUE","isDefined","v","isSameType","a","b","areAllSameType","list","every","current","i","prev","undefined","isEmptyObjectOrArray","obj","isObject","isEmpty","value","key","extractFieldExamples","nodes","mergeWith","isArray","next","po","pn","stack","isNumber","isInteger","array","concat","filter","length","includes","slice","merged","buildFieldEnumValues","enumValues","values","maxDepth","safe","delimiter","forEach","field","module","exports"],"mappings":"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","file":"data-tree-utils.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst flatten = require(`flat`)\nconst typeOf = require(`type-of`)\n\nconst createKey = require(`./create-key`)\n\nconst INVALID_VALUE = Symbol(`INVALID_VALUE`)\nconst isDefined = v => v != null\n\nconst isSameType = (a, b) => a == null || b == null || typeOf(a) === typeOf(b)\nconst areAllSameType = list =>\n  list.every((current, i) => {\n    let prev = i ? list[i - 1] : undefined\n    return isSameType(prev, current)\n  })\n\nconst isEmptyObjectOrArray = (obj: any): boolean => {\n  if (obj === INVALID_VALUE) {\n    return true\n    // Simple \"is object empty\" check.\n  } else if (_.isObject(obj) && _.isEmpty(obj)) {\n    return true\n  } else if (_.isObject(obj)) {\n    return _.every(obj, (value, key) => {\n      if (!isDefined(value)) {\n        return true\n      } else if (_.isObject(value)) {\n        return isEmptyObjectOrArray(value)\n      } else {\n        return false\n      }\n    })\n  }\n  return false\n}\n\n/**\n * Takes an array of source nodes and returns a pristine\n * example that can be used to infer types.\n *\n * Arrays are flattened to either: `null` for empty or sparse arrays or a\n * an array of a sigle merged example. e.g:\n *\n *  - ['red'], ['blue', 'yellow'] -> ['red']\n *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]\n *\n * @param {*Nodes} args\n */\nconst extractFieldExamples = (nodes: any[]) =>\n  // $FlowFixMe\n  _.mergeWith(\n    _.isArray(nodes[0]) ? [] : {},\n    ...nodes,\n    (obj, next, key, po, pn, stack) => {\n      if (obj === INVALID_VALUE) return obj\n\n      // TODO: if you want to support infering Union types this should be handled\n      // differently. Maybe merge all like types into examples for each type?\n      // e.g. union: [1, { foo: true }, ['brown']] -> Union Int|Object|List\n      if (!isSameType(obj, next)) return INVALID_VALUE\n\n      if (!_.isArray(obj || next)) {\n        // Prefer floats over ints as they're more specific.\n        if (obj && _.isNumber(obj) && !_.isInteger(obj)) return obj\n        if (obj === null) return next\n        if (next === null) return obj\n        return undefined\n      }\n\n      let array = [].concat(obj, next).filter(isDefined)\n\n      if (!array.length) return null\n      if (!areAllSameType(array)) return INVALID_VALUE\n\n      // Linked node arrays don't get reduced further as we\n      // want to preserve all the linked node types.\n      if (_.includes(key, `___NODE`)) {\n        return array\n      }\n\n      // primitive values don't get merged further, just take the first item\n      if (!_.isObject(array[0])) return array.slice(0, 1)\n      let merged = extractFieldExamples(array)\n      return isDefined(merged) ? [merged] : null\n    }\n  )\n\nconst buildFieldEnumValues = (nodes: any[]) => {\n  const enumValues = {}\n  const values = flatten(extractFieldExamples(nodes), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n  Object.keys(values).forEach(field => {\n    if (values[field] == null) return\n    enumValues[createKey(field)] = { field }\n  })\n\n  return enumValues\n}\n\nmodule.exports = {\n  INVALID_VALUE,\n  extractFieldExamples,\n  buildFieldEnumValues,\n  isEmptyObjectOrArray,\n}\n"]}